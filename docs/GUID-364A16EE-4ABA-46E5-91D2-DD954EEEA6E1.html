<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us" data-whc_version="24.1">
    <head><link rel="shortcut icon" href="oxygen-webhelp\template\resources/images/favicon.ico"/><link rel="icon" href="oxygen-webhelp\template\resources/images/favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="The USB Driver operates or can operate in the Host mode when it is initialized for Host mode or Dual Role operation. When operating in Host mode, the USB Driver is also referred to as the Host ..."/><meta name="copyright" content="(C) Copyright 2024"/><meta name="generator" content="DITA-OT"/><title>4.1.5 USB Driver Host Mode Operation</title><!--  Generated with Oxygen version 24.1, build number 2022062014.  --><meta name="wh-path2root" content=""/><meta name="wh-toc-id" content="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1-d5059e5461"/><meta name="wh-source-relpath" content="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1.xml"/><meta name="wh-out-relpath" content="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1.html"/>
    <!-- Latest compiled and minified Bootstrap CSS -->
    <link rel="stylesheet" type="text/css" href="./oxygen-webhelp/lib/bootstrap/css/bootstrap.min.css"/>
    
    <link rel="stylesheet" href="./oxygen-webhelp/lib/jquery-ui/jquery-ui.min.css"/>
    
    <!-- Template default styles  -->
    <link rel="stylesheet" type="text/css" href="./oxygen-webhelp/app/topic-page.css?buildId=2022062014"/>
    
    
    <script src="./oxygen-webhelp/lib/jquery/jquery-3.5.1.min.js"></script>
    
    <script data-main="./oxygen-webhelp/app/topic-page.js" src="./oxygen-webhelp/lib/requirejs/require.js"></script>
<link rel="stylesheet" type="text/css" href="oxygen-webhelp/template/microchip.css?buildId=2022062014"/><link rel="stylesheet" type="text/css" href="oxygen-webhelp/template/notes.css?buildId=2022062014"/>
<script src="mchp-context-help.js"></script>
<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,600,300" rel="stylesheet" type="text/css"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async="" type="text/javascript"></script>
    <script src="https://assets.adobedtm.com/6a72a357eb48/a636c708c7fe/launch-0b0023397020.min.js"></script><!-- Adobe Analytics -->
</head>

    <body id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            Jump to main content
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="index.html" class=" wh_logo d-none d-sm-block "><img src="oxygen-webhelp\template\resources/images/microchip.png" alt="MPLAB® Harmony 3 USB Library &#xA;    "/></a>
                    <div class=" wh_publication_title "><a href="index.html">MPLAB® Harmony 3 USB Library 
    </a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        </div>
    </div>
</header>
        
        
         
        
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="search.html"><div class="d-flex justify-contents-around"><div class="flex-grow-1"></div><div class="position-relative flex-grow-1"><input type="search" placeholder="Search " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="Search query" required="required"/><button type="submit" class="wh_search_button" aria-label="Search"><span class="search_input_text">Search</span></button></div><div class="align-self-center flex-grow-1 ml-2"></div></div></form>
            
            <div class="mchp-color-stripe-grid-container">
  <div class="mchp-main-bar mchp-orange-bar"></div>
  <div class="mchp-main-bar mchp-blue-bar"></div>
  <div class="mchp-main-bar mchp-green-bar"></div>
</div>
            
        </div>
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="index.html"><span>Home</span></a></span></li><li><div class="topicref" data-id="GUID-6AFB98D6-0272-4DED-BBAB-39EECD8DDB5F"><div class="title"><a href="GUID-6AFB98D6-0272-4DED-BBAB-39EECD8DDB5F.html"><ph xmlns="http://www.oxygenxml.com/ns/webhelp/toc">4</ph>
USB Common Driver Interface</a></div></div></li><li><div class="topicref" data-id="GUID-7B57189D-AB41-4208-8FBA-0C1C2C9DAE39"><div class="title"><a href="GUID-7B57189D-AB41-4208-8FBA-0C1C2C9DAE39.html"><ph xmlns="http://www.oxygenxml.com/ns/webhelp/toc">4.1</ph>
Common Interface</a></div></div></li><li class="active"><div class="topicref" data-id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1"><div class="title"><a href="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1.html"><ph xmlns="http://www.oxygenxml.com/ns/webhelp/toc">4.1.5</ph>
USB Driver Host Mode Operation</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="Toggle search highlights" title="Toggle search highlights"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="Collapse sections" title="Collapse sections"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="Print this page" aria-label="Print this page"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            <div class="row" style="margin-top: -1em;"><div class="col-lg-7 col-md-7 col-sm-12 offset-lg-3 offset-md-3 text-right border-bottom mb-1"><h2 class="text-dark header_title">
    </h2></div></div>
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem" aria-expanded="false"><div data-tocid="GUID-D9F90103-F97D-468D-90FC-EA3E186842D9-d5059e11" class="topicref" data-id="GUID-D9F90103-F97D-468D-90FC-EA3E186842D9" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action GUID-D9F90103-F97D-468D-90FC-EA3E186842D9-d5059e11-link" class="wh-expand-btn"></span><div class="title"><a href="GUID-D9F90103-F97D-468D-90FC-EA3E186842D9.html" id="GUID-D9F90103-F97D-468D-90FC-EA3E186842D9-d5059e11-link"><ph xmlns="http://www.oxygenxml.com/ns/webhelp/toc">1</ph>
Release Information</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="GUID-61902145-0FA6-4DE3-845C-B14852166EAE-d5059e27" class="topicref" data-id="GUID-61902145-0FA6-4DE3-845C-B14852166EAE" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action GUID-61902145-0FA6-4DE3-845C-B14852166EAE-d5059e27-link" class="wh-expand-btn"></span><div class="title"><a href="GUID-61902145-0FA6-4DE3-845C-B14852166EAE.html" id="GUID-61902145-0FA6-4DE3-845C-B14852166EAE-d5059e27-link"><ph xmlns="http://www.oxygenxml.com/ns/webhelp/toc">2</ph>
USB Device Libraries</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="GUID-B14EBEC0-7590-4740-800B-6CE5FE9AB121-d5059e3093" class="topicref" data-id="GUID-B14EBEC0-7590-4740-800B-6CE5FE9AB121" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action GUID-B14EBEC0-7590-4740-800B-6CE5FE9AB121-d5059e3093-link" class="wh-expand-btn"></span><div class="title"><a href="GUID-B14EBEC0-7590-4740-800B-6CE5FE9AB121.html" id="GUID-B14EBEC0-7590-4740-800B-6CE5FE9AB121-d5059e3093-link"><ph xmlns="http://www.oxygenxml.com/ns/webhelp/toc">3</ph>
USB Host Libraries</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="GUID-6AFB98D6-0272-4DED-BBAB-39EECD8DDB5F-d5059e5397" class="topicref" data-id="GUID-6AFB98D6-0272-4DED-BBAB-39EECD8DDB5F" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action GUID-6AFB98D6-0272-4DED-BBAB-39EECD8DDB5F-d5059e5397-link" class="wh-expand-btn"></span><div class="title"><a href="GUID-6AFB98D6-0272-4DED-BBAB-39EECD8DDB5F.html" id="GUID-6AFB98D6-0272-4DED-BBAB-39EECD8DDB5F-d5059e5397-link"><ph xmlns="http://www.oxygenxml.com/ns/webhelp/toc">4</ph>
USB Common Driver Interface</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="true"><div data-tocid="GUID-7B57189D-AB41-4208-8FBA-0C1C2C9DAE39-d5059e5405" class="topicref" data-id="GUID-7B57189D-AB41-4208-8FBA-0C1C2C9DAE39" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action GUID-7B57189D-AB41-4208-8FBA-0C1C2C9DAE39-d5059e5405-link" class="wh-expand-btn"></span><div class="title"><a href="GUID-7B57189D-AB41-4208-8FBA-0C1C2C9DAE39.html" id="GUID-7B57189D-AB41-4208-8FBA-0C1C2C9DAE39-d5059e5405-link"><ph xmlns="http://www.oxygenxml.com/ns/webhelp/toc">4.1</ph>
Common Interface</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="GUID-DAE7BD2C-129E-4F03-BF5D-3A315C9DEF45-d5059e5413" class="topicref" data-id="GUID-DAE7BD2C-129E-4F03-BF5D-3A315C9DEF45" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action GUID-DAE7BD2C-129E-4F03-BF5D-3A315C9DEF45-d5059e5413-link" class="wh-expand-btn"></span><div class="title"><a href="GUID-DAE7BD2C-129E-4F03-BF5D-3A315C9DEF45.html" id="GUID-DAE7BD2C-129E-4F03-BF5D-3A315C9DEF45-d5059e5413-link"><ph xmlns="http://www.oxygenxml.com/ns/webhelp/toc">4.1.1</ph>
Driver Host Mode Client Functions</a></div></div></li><li role="treeitem"><div data-tocid="GUID-1B002121-F8DD-4F43-B052-BF0BD1C4CEC6-d5059e5437" class="topicref" data-id="GUID-1B002121-F8DD-4F43-B052-BF0BD1C4CEC6" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="GUID-1B002121-F8DD-4F43-B052-BF0BD1C4CEC6.html" id="GUID-1B002121-F8DD-4F43-B052-BF0BD1C4CEC6-d5059e5437-link"><ph xmlns="http://www.oxygenxml.com/ns/webhelp/toc">4.1.2</ph>
Driver Device Mode Client Functions</a></div></div></li><li role="treeitem"><div data-tocid="GUID-0F4E88DE-15B9-4CE8-9B09-044A80E81C4D-d5059e5445" class="topicref" data-id="GUID-0F4E88DE-15B9-4CE8-9B09-044A80E81C4D" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="GUID-0F4E88DE-15B9-4CE8-9B09-044A80E81C4D.html" id="GUID-0F4E88DE-15B9-4CE8-9B09-044A80E81C4D-d5059e5445-link"><ph xmlns="http://www.oxygenxml.com/ns/webhelp/toc">4.1.3</ph>
Driver General Client Functions</a></div></div></li><li role="treeitem"><div data-tocid="GUID-655F3E4F-8C51-4725-9838-73500FD7AF00-d5059e5453" class="topicref" data-id="GUID-655F3E4F-8C51-4725-9838-73500FD7AF00" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="GUID-655F3E4F-8C51-4725-9838-73500FD7AF00.html" id="GUID-655F3E4F-8C51-4725-9838-73500FD7AF00-d5059e5453-link"><ph xmlns="http://www.oxygenxml.com/ns/webhelp/toc">4.1.4</ph>
Opening the Driver</a></div></div></li><li role="treeitem" class="active"><div data-tocid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1-d5059e5461" class="topicref" data-id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1.html" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1-d5059e5461-link"><ph xmlns="http://www.oxygenxml.com/ns/webhelp/toc">4.1.5</ph>
USB Driver Host Mode Operation</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="GUID-4D46C075-0FAB-49DF-8561-98820CD2536B-d5059e5469" class="topicref" data-id="GUID-4D46C075-0FAB-49DF-8561-98820CD2536B" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action GUID-4D46C075-0FAB-49DF-8561-98820CD2536B-d5059e5469-link" class="wh-expand-btn"></span><div class="title"><a href="GUID-4D46C075-0FAB-49DF-8561-98820CD2536B.html" id="GUID-4D46C075-0FAB-49DF-8561-98820CD2536B-d5059e5469-link"><ph xmlns="http://www.oxygenxml.com/ns/webhelp/toc">4.1.6</ph>
USB Driver Device Mode Operation</a></div></div></li></ul></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="GUID-0FB3F908-88EE-45CE-94F5-E97AF9049C9B-d5059e5501" class="topicref backmatter backmatter_parent" data-id="GUID-0FB3F908-88EE-45CE-94F5-E97AF9049C9B" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action GUID-0FB3F908-88EE-45CE-94F5-E97AF9049C9B-d5059e5501-link" class="wh-expand-btn"></span><div class="title"><a href="GUID-0FB3F908-88EE-45CE-94F5-E97AF9049C9B.html" id="GUID-0FB3F908-88EE-45CE-94F5-E97AF9049C9B-d5059e5501-link">Microchip Information</a></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article role="article" aria-labelledby="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__GUID-1A9B23AC-E243-4F3B-9061-1AB41BCE53AC">
<h1 class="- topic/title title topictitle1" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__GUID-1A9B23AC-E243-4F3B-9061-1AB41BCE53AC" style="">4.1.5 USB Driver Host Mode Operation</h1>
    <div class="- topic/body body">
        <p class="- topic/p p">The USB Driver operates or can operate in the Host mode when it is initialized for Host
            mode or Dual Role operation. When operating in Host mode, the USB Driver is also
            referred to as the Host Controller Driver (HCD). In Dual Role mode, the USB Driver will
            switch to Host mode when the USB Driver Host Root Hub Operation Enable function is
            called. </p>
        <p class="- topic/p p">The USB Driver Client must perform these steps to operate the USB Driver in Host
            mode.</p>
        <ol class="- topic/ol ol" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__OL_UXY_TZ2_Q1C" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__OL_UXY_TZ2_Q1C">
            <li class="- topic/li li" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__GUID-FE4C48BA-15BB-4E6C-AA9C-C7E5433AEE44" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__GUID-FE4C48BA-15BB-4E6C-AA9C-C7E5433AEE44">Open the USB Driver to obtain the driver handle.</li>
            <li class="- topic/li li" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__GUID-5E6B5DA3-31D7-4C89-8FDA-EB5B5225CF17" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__GUID-5E6B5DA3-31D7-4C89-8FDA-EB5B5225CF17">Set the event handler.</li>
            <li class="- topic/li li" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__GUID-0B1644FC-66A9-424B-ABEF-090185774328" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__GUID-0B1644FC-66A9-424B-ABEF-090185774328">Call the Root Hub Control function to obtain the speed of the root hub, the number
                of ports that the root hub supports, and the maximum current that the root hub VBUS
                can supply.</li>
            <li class="- topic/li li" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__GUID-2BB68768-5C7B-41F9-AB4A-4B7DEEF4BE8B" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__GUID-2BB68768-5C7B-41F9-AB4A-4B7DEEF4BE8B">Calls the Root Hub Initialize function with an identifier parameter. This
                    <code class="+ topic/ph pr-d/codeph ph codeph">identifier</code> parameter allows the Host Stack to uniquely identify
                the root hub when where there are multiple root hubs.</li>
            <li class="- topic/li li" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__GUID-8BFBC1F2-300D-4BEE-8775-6B51F8D09D2F" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__GUID-8BFBC1F2-300D-4BEE-8775-6B51F8D09D2F">The Driver Client will then enable the root hub operation and will wait until the
                root hub operation is enabled.</li>
            <li class="- topic/li li" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__GUID-6E89B4C5-5B66-46B1-A12E-96E3582594A4" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__GUID-6E89B4C5-5B66-46B1-A12E-96E3582594A4">The Driver Client can now call the USB Driver Host mode functions.</li>
        </ol>
        <p class="- topic/p p">The following sections explain Steps 2 through 6 in more detail.</p>
        <section class="- topic/section section" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_NDB_C1F_Q1C" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_NDB_C1F_Q1C"><h2 class="- topic/title title sectiontitle"><strong class="+ topic/ph hi-d/b ph b">Handling Host Mode Driver Events</strong></h2>
            
            <p class="- topic/p p">Currently, the HCD does not provide any events to the client. The client can
                optionally register an event handler through the eventHandlerSet function pointer in
                the DRV_USB_HOST_INTERFACE structure. Future releases of the USB Driver may contain
                features that provide events to the Driver Client. Please refer to the following
                    <strong class="+ topic/ph hi-d/b ph b">Root Hub Operation</strong> section for details on how the driver indicates device
                attach and detach to the client.</p>
        </section>
        <section class="- topic/section section" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_BNC_D1F_Q1C" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_BNC_D1F_Q1C"><h2 class="- topic/title title sectiontitle"><strong class="+ topic/ph hi-d/b ph b">Root Hub Operation</strong></h2>
            
            <p class="- topic/p p">A key feature of the HCD is the Root Hub Driver. The Root Hub Driver emulates hub
                operation in USB Driver software and provides a hub like interface to the USB Host
                Layer. The USB Host Layer treats the root hub like an external hub. This simplifies
                the implementation of USB Host Layer while supporting multiple devices through a
                hub. In that, the USB Host layer does not have to treat a device connected directly
                to the USB peripheral differently than a device connected to an external hub. The
                following code example shows how the USB Host Layer calls the root hub function to
                obtain information about the root hub.</p>
        </section>
        <pre class="- topic/pre pre" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_PJ4_21F_Q1C" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_PJ4_21F_Q1C"><em class="+ topic/ph hi-d/i ph i">/* This code example shows how the USB Host Layer calls the root hub functions to
 * obtain information about the root. The USB Host Layer first opens the HCD and
 * then accesses the root hub functions through the rootHubInterface member of
 * hcdInterface. rootHubInterface is of the type DRV_USB_ROOT_HUB_INTERFACE and
 * the hcdInterface is of the type of DRV_USB_HOST_INTERFACE. */</em>
<em class="+ topic/ph hi-d/i ph i">/* The code example shows how the Host Layer gets to know the root hub operation
 * speed, number of root hub ports and the maximum amount of current that the
 * root can supply. These function can be called only after HCD was opened and a
 * valid driver handle obtained. */</em>
<strong class="+ topic/ph hi-d/b ph b">case</strong> USB_HOST_BUS_STATE_ENABLING:

    <em class="+ topic/ph hi-d/i ph i">/* The bus is being enabled. Try opening the HCD */</em>
    busObj-&gt;hcdHandle = busObj-&gt;hcdInterface-&gt;open(busObj-&gt;hcdIndex, DRV_IO_INTENT_EXCLUSIVE |
            DRV_IO_INTENT_NONBLOCKING | DRV_IO_INTENT_READWRITE );

    <em class="+ topic/ph hi-d/i ph i">/* Validate the Open function status */</em>
    <strong class="+ topic/ph hi-d/b ph b">if</strong> (DRV_HANDLE_INVALID == busObj-&gt;hcdHandle )
    {
        <em class="+ topic/ph hi-d/i ph i">/* The driver may not open the first time. This is okay. We
         * should try opening it again. The state of bus is not
         * changed. */</em>
    }
    <strong class="+ topic/ph hi-d/b ph b">else</strong>
    {
        <em class="+ topic/ph hi-d/i ph i">/* Update the bus root hub information with the
         * details of the controller. Get the bus speed, number of
         * ports, the maximum current that the HCD can supply,
         * pointer to the root hub port functions. */</em>

        SYS_DEBUG_PRINT(SYS_ERROR_INFO,
             "\r\nUSB Host Layer: Bus %d Root Hub Driver Opened.",hcCount);

        busObj-&gt;rootHubInfo.speed =
             busObj-&gt;hcdInterface-&gt;rootHubInterface.rootHubSpeedGet(busObj-&gt;hcdHandle);

        busObj-&gt;rootHubInfo.ports =
             busObj-&gt;hcdInterface-&gt;rootHubInterface.rootHubPortNumbersGet(busObj-&gt;hcdHandle);

        busObj-&gt;rootHubInfo.power =
             busObj-&gt;hcdInterface-&gt;rootHubInterface.rootHubMaxCurrentGet(busObj-&gt;hcdHandle);

        busObj-&gt;rootHubInfo.rootHubPortInterface =
             busObj-&gt;hcdInterface-&gt;rootHubInterface.rootHubPortInterface;</pre>
        <p class="- topic/p p">The USB Host Layer must initialize and enable the operation of the root hub. While
            initializing the Root Hub Driver, the Host layer will assign a unique identifier to the
            root hub. The root hub will return this value as the parent identifier while calling the
            USB_HOST_DeviceEnumerate function. The USB Host Layer must then enable the operation of
            the root hub driver. This will cause the root hub driver to detect device attach and
            detach. The following code example shows how the USB Host Layer initializes and enables
            the root hub driver.</p>
        <pre class="- topic/pre pre" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_ICX_H1F_Q1C" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_ICX_H1F_Q1C"><em class="+ topic/ph hi-d/i ph i">/* The following code example show how the USB Host Layer initializes the root
 * hub and then enables the root hub operation. The
 * rootHubDevice-&gt;deviceIdentifier is a unique identifier that allows the USB
 * Host layer to identify this root hub. It is returned by the root hub driver
 * in the USB_HOST_DeviceEnumerate() function as the parent identifier when the
 * device is connected to the root hub. */</em>
<em class="+ topic/ph hi-d/i ph i">/* The hcdHandle is the driver handle. The hcdInterface pointer is of the type
 * DRV_USB_HOST_INTERFACE and points to the HCD interface. */</em>

busObj-&gt;hcdInterface-&gt;rootHubInterface.rootHubInitialize( busObj-&gt;hcdHandle ,
                                                          rootHubDevice-&gt;deviceIdentifier );
busObj-&gt;hcdInterface-&gt;rootHubInterface.rootHubOperationEnable( busObj-&gt;hcdHandle , <strong class="+ topic/ph hi-d/b ph b">true</strong> );
</pre>
        <p class="- topic/p p">When a device is attached, the Root Hub Driver will implement the required settling
            attach settling delay and will then call the USB Host Layer’s USB_HOST_DeviceEnumerate
            function to enumerate the device. While calling this function, the root hub driver will
            provide the identifier that was provided to it in its initialize function. The
            USB_HOST_DeviceEnumerate function will return an identifier which uniquely identifies
            the attached device. The root hub driver uses this value to identify the device to the
            Host when the USB_HOST_DeviceDenumerate function is called on device detach. The
            following code example shows how the Root Hub driver calls the USB_HOST_DeviceEnumerate
            and the USB_HOST_DeviceDenumerate functions.</p>
        <pre class="- topic/pre pre" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_JCX_H1F_Q1C" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_JCX_H1F_Q1C"><em class="+ topic/ph hi-d/i ph i">/* The following code shows how the root hub driver calls the
 * USB_HOST_DeviceEnumerate() function in the device attach interrupt. As seen
 * here, the root hub returns the identifier that the USB Host Layer assigned to
 * it the rootHubInitialize function call. The pUSBDrvObj-&gt;usbHostDeviceInfo
 * variable contains this identifier. */</em>
<strong class="+ topic/ph hi-d/b ph b">if</strong>(PLIB_USB_InterruptFlagGet(usbID, USB_INT_ATTACH))
{
    <em class="+ topic/ph hi-d/i ph i">/* We can treat this as a valid attach. We then clear the
     * detach flag and enable the detach interrupt. We enable
     * the Transaction interrupt */</em>

    PLIB_USB_InterruptFlagClear(usbID, USB_INT_HOST_DETACH);
    PLIB_USB_InterruptEnable(usbID, USB_INT_HOST_DETACH);
    PLIB_USB_InterruptEnable(usbID, USB_INT_TOKEN_DONE);

    <em class="+ topic/ph hi-d/i ph i">/* Ask the Host layer to enumerate this device. While calling
     * this function, the UHD of the parent device which is the
     * root hub in this case.
     * */</em>
    pUSBDrvObj-&gt;attachedDeviceObjHandle = USB_HOST_DeviceEnumerate
                                          (pUSBDrvObj-&gt;usbHostDeviceInfo, 0);
}

<em class="+ topic/ph hi-d/i ph i">/* The following code example shows how the root hub driver calls the
 * USB_HOST_DeviceDenumerate() function in the device detach interrupt. Note how
 * the attachedDeviceObjHandle that was assigned at the time of device
 * enumeration is returned to the Host Layer to let the Host know which device
 * is being detached. */</em>
<strong class="+ topic/ph hi-d/b ph b">if</strong>((usbInterrupts &amp; USB_INT_HOST_DETACH) &amp;&amp; (enabledUSBInterrupts &amp; USB_INT_HOST_DETACH))
{
    <em class="+ topic/ph hi-d/i ph i">/* Perform other detach related handling */</em>
    <em class="+ topic/ph hi-d/i ph i">/* Ask the Host Layer to de-enumerate this device. */</em>
    USB_HOST_DeviceDenumerate (pUSBDrvObj-&gt;attachedDeviceObjHandle);

    <em class="+ topic/ph hi-d/i ph i">/* Disable the LS Direct Connect. It may have been enabled if the last
     attach was for a Low-Speed device. */</em>
    PLIB_USB_EP0LSDirectConnectDisable(pUSBDrvObj-&gt;usbID);

    <em class="+ topic/ph hi-d/i ph i">/* Continue to perform detach handling */</em>
}</pre>
        <section class="- topic/section section" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_MZT_K1F_Q1C" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_MZT_K1F_Q1C"><h2 class="- topic/title title sectiontitle"><strong class="+ topic/ph hi-d/b ph b">Root Hub Port Operation</strong></h2>
            
            <p class="- topic/p p">The HCD Root Hub Driver exposes a set of port related functions that allow the USB
                Host Layer to control the port. The most commonly used functions are the function to
                reset the port and get the port speed. In this case, this is the speed of the
                attached device. The following code example shows how the USB Host Layer calls the
                hubPortReset, hubPortResetIsComplete and hubPortSpeedGet port functions.</p>
        </section>
        <pre class="- topic/pre pre" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_APS_M1F_Q1C" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_APS_M1F_Q1C"><em class="+ topic/ph hi-d/i ph i">/* The following code shows an example of how the Host Layer called the
 * hubPortReset function to reset the port to which the device is connected.
 * The code proceeds with the port reset if no device on the bus is in an
 * enumeration state. It will then call the hubPortReset function of the parent
 * hub of the device. The parent hub, hubInterface member of deviceObj points to
 * this driver, can be the root hub or an external hub */</em>
<strong class="+ topic/ph hi-d/b ph b">if</strong>(!busObj-&gt;deviceIsEnumerating)
{
    <em class="+ topic/ph hi-d/i ph i">/* Remember which device is enumerating */</em>
    busObj-&gt;enumeratingDeviceIdentifier = deviceObj-&gt;deviceIdentifier;

    <em class="+ topic/ph hi-d/i ph i">/* Grab the flag */</em>
    busObj-&gt;deviceIsEnumerating = <strong class="+ topic/ph hi-d/b ph b">true</strong>;

    <em class="+ topic/ph hi-d/i ph i">/* Reset the device */</em>
    deviceObj-&gt;hubInterface-&gt;hubPortReset( deviceObj-&gt;hubHandle, deviceObj-&gt;devicePort );
}

<em class="+ topic/ph hi-d/i ph i">/* The following code example shows how the Host checks if the port reset
 * operation has completed. If the reset operation has completed, the speed of
 * the attached device can be obtained. The reset settling delay can then be
 * started. */</em>
<strong class="+ topic/ph hi-d/b ph b">case</strong> USB_HOST_DEVICE_STATE_WAITING_FOR_RESET_COMPLETE:

    <em class="+ topic/ph hi-d/i ph i">/* Check if the reset has completed */</em>
    <strong class="+ topic/ph hi-d/b ph b">if</strong>(deviceObj-&gt;hubInterface-&gt;hubPortResetIsComplete
                 ( deviceObj-&gt;hubHandle ,deviceObj-&gt;devicePort ))
    {
        <em class="+ topic/ph hi-d/i ph i">/* The reset has completed. We can also obtain the speed of the
         * device. We give a reset recovery delay to the device */</em>

        deviceObj-&gt;speed = deviceObj-&gt;hubInterface-&gt;hubPortSpeedGet
                           (deviceObj-&gt;hubHandle, deviceObj-&gt;devicePort);

        deviceObj-&gt;deviceState = USB_HOST_DEVICE_STATE_START_RESET_SETTLING_DELAY;
    }</pre>
        <section class="- topic/section section" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_B1J_41F_Q1C" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_B1J_41F_Q1C"><h2 class="- topic/title title sectiontitle"><strong class="+ topic/ph hi-d/b ph b">Opening and Closing a Pipe</strong></h2>
            
            <p class="- topic/p p">The HCD client can open a pipe to the device after resetting the device. The USB Host
                Layer calls the hostPipeSetup function in the DRV_USB_HOST_INTERFACE structure to
                open a pipe. The USB Host Layer must open a pipe to communicate to a specific
                endpoint on a target device. While opening the pipe, the USB Host Layer must specify
                parameters which specify the address of the target device, the type of the transfer
                that the pipe must support and the speed of the pipe. If the device is connected to
                a hub, the address of the hub must be specified. The HCD Pipe Setup function <em class="+ topic/ph hi-d/i ph i">is
                    not</em> interrupt-safe. It should not be called in any event handler that
                executes in an interrupt context. </p>
            <p class="- topic/p p">The Pipe Setup function returns a valid pipe handle if the pipe was opened
                successfully. Pipe creation may fail if the target device was disconnected or if
                there are insufficient resources to open the pipe. The pipe handle is then used
                along with the hostIRPSubmit function to transfer data between the Host and the
                device. The following code shows example usage of a Pipe Open function.</p>
        </section>
        <pre class="- topic/pre pre" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_DQJ_Q1F_Q1C" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_DQJ_Q1F_Q1C"><em class="+ topic/ph hi-d/i ph i">/* The following code example shows how the Host Layer uses the hostPipeSetup
 * function to open a control pipe to the attached device. Most of the
 * parameters that are passed to this function become known when the device is
 * attached. The pipe handle is checked for validity after the hostPipeSetup
 * function call. */</em>
<strong class="+ topic/ph hi-d/b ph b">if</strong>(busObj-&gt;timerExpired)
{
    busObj-&gt;busOperationsTimerHandle = SYS_TMR_HANDLE_INVALID;
    <em class="+ topic/ph hi-d/i ph i">/* Settling delay has completed. Now we can open default address
     * pipe and and get the configuration descriptor */</em>

    SYS_DEBUG_PRINT(SYS_ERROR_INFO,
                    "\r\nUSB Host Layer: Bus %d Device Reset Complete.", busIndex);

    deviceObj-&gt;controlPipeHandle =
               deviceObj-&gt;hcdInterface-&gt;hostPipeSetup( deviceObj-&gt;hcdHandle,
               USB_HOST_DEFAULT_ADDRESS , 0 <em class="+ topic/ph hi-d/i ph i">/* Endpoint */</em>,
               deviceObj-&gt;hubAddress <em class="+ topic/ph hi-d/i ph i">/* Address of the hub */</em>,
               deviceObj-&gt;devicePort <em class="+ topic/ph hi-d/i ph i">/* Address of the port */</em>,
               USB_TRANSFER_TYPE_CONTROL, <em class="+ topic/ph hi-d/i ph i">/* Type of pipe to open */</em>
               0 <em class="+ topic/ph hi-d/i ph i">/* bInterval */</em>, 8 <em class="+ topic/ph hi-d/i ph i">/* Endpoint Size */</em>, deviceObj-&gt;speed );

    <strong class="+ topic/ph hi-d/b ph b">if</strong>(DRV_USB_HOST_PIPE_HANDLE_INVALID == deviceObj-&gt;controlPipeHandle)
    {
        <em class="+ topic/ph hi-d/i ph i">/* We need a pipe else we cannot proceed */</em>
        SYS_DEBUG_PRINT(SYS_ERROR_DEBUG,
        "\r\nUSB Host Layer: Bus %d Could not open control pipe. Device not supported.", busIndex);
    }
}</pre>
        <p class="- topic/p p">An open pipe consumes computational and memory resources and must therefore must be
            closed if it will not be used. This is especially true of pipes to a device that is
            detached. The Host Layer calls the hostPipeClose function in the DRV_USB_HOST_INTERFACE
            structure to close the pipe. The pipe to be closed is specified by the pipe handle. The
            Pipe Close function can be called from an event handler. It is interrupt safe. Closing a
            pipe will cancel all pending transfers on that pipe. The IRP callback for such canceled
            transfers will be called with the status USB_HOST_IRP_STATUS_ABORTED. The following code
            example shows an example of closing the pipe.</p>
        <pre class="- topic/pre pre" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_ECG_S1F_Q1C" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_ECG_S1F_Q1C"><em class="+ topic/ph hi-d/i ph i">/* The following code example shows an example of how the Host Layer calls the
 * hostPipeClose function to close an open pipe. Pipe should be closed if it
 * will not used. An open pipe consumes memory resources. In this example, the
 * Host Layer closes the pipe if it was not able successfully submit an IRP to
 * this pipe. */</em>
<em class="+ topic/ph hi-d/i ph i">/* Submit the IRP */</em>
<strong class="+ topic/ph hi-d/b ph b">if</strong>(USB_ERROR_NONE != deviceObj-&gt;hcdInterface-&gt;hostIRPSubmit
                  ( deviceObj-&gt;controlPipeHandle, &amp; (deviceObj-&gt;controlTransferObj.controlIRP)))
{
    <em class="+ topic/ph hi-d/i ph i">/* We need to be able to send the IRP. We move the device to
     * an error state. Close the pipe and send an event to the
     * application. The assigned address will be released when
     * the device in unplugged. */</em>

    SYS_DEBUG_PRINT(SYS_ERROR_DEBUG,
        "\r\nUSB Host Layer: Bus %d Set Address IRP failed. Device not supported.", busIndex);

    <em class="+ topic/ph hi-d/i ph i">/* Move the device to error state */</em>
    deviceObj-&gt;deviceState = USB_HOST_DEVICE_STATE_ERROR;

    <em class="+ topic/ph hi-d/i ph i">/* Close the pipe as we are about mark this device as unsupported. */</em>
    deviceObj-&gt;hcdInterface-&gt;hostPipeClose(deviceObj-&gt;controlPipeHandle);
}</pre>
        <section class="- topic/section section" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_NCZ_T1F_Q1C" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_NCZ_T1F_Q1C"><h2 class="- topic/title title sectiontitle"><strong class="+ topic/ph hi-d/b ph b">Transferring Data to an Attached Device</strong></h2>
            
            <p class="- topic/p p">The USB Host Layer, the HCD client, needs to transfer data to the attached device to
                understand the device capabilities and to operate the device. The HCD uses a concept
                of Input Output Request Packet (IRP) to transfer data to and from the attached
                device. IRPs are transported over pipes which are setup by calling the USB Driver
                Pipe Setup function. </p>
            <p class="- topic/p p">A Host IRP is a USB_HOST_IRP type data structure. The IRP is created by the Host
                layer and submitted to the HCD for processing through the hostIRPSubmit function. At
                the time of submitting the IRP, the pipe over which the IRP must be transported is
                specified. The data request in the IRP is transported using the attributes of pipe.
                When an IRP is submitted to the HCD, it is owned by the HCD and cannot be modified
                by the Host Layer until the HCD issues an IRP callback. The HCD will issue the IRP
                callback when it has completed or terminated processing of the IRP. </p>
            <p class="- topic/p p">An IRP does not have its own transfer type. It inherits the properties of the pipe to
                which it is submitted. Hence an IRP becomes a control transfer IRP it was submitted
                to a control transfer pipe. A pipe allows multiple IRPs to be queued. This allows
                the Host Layer to submit IRPs to a pipe even while an IRP is being processed on the
                pipe. The HCD will process an IRP in the order that it was received. The following
                code example shows the USB_HOST_IRP data structure.</p>
        </section>
        <pre class="- topic/pre pre" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_RRR_V1F_Q1C" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_RRR_V1F_Q1C"><em class="+ topic/ph hi-d/i ph i">/* The following code example shows the USB_HOST_IRP structure. The Host Layer
 * uses this structure to place data transfer requests on a pipe. */</em>
<strong class="+ topic/ph hi-d/b ph b">typedef</strong><strong class="+ topic/ph hi-d/b ph b">struct</strong> _USB_HOST_IRP
{
    <em class="+ topic/ph hi-d/i ph i">/* Points to the 8 byte setup command packet in case this is a IRP is
     * scheduled on a CONTROL pipe. Should be NULL otherwise */</em>
    <strong class="+ topic/ph hi-d/b ph b">void</strong> * setup;

    <em class="+ topic/ph hi-d/i ph i">/* Pointer to data buffer */</em>
    <strong class="+ topic/ph hi-d/b ph b">void</strong> * data;

    <em class="+ topic/ph hi-d/i ph i">/* Size of the data buffer */</em>
    <strong class="+ topic/ph hi-d/b ph b">unsigned</strong><strong class="+ topic/ph hi-d/b ph b">int</strong> size;

    <em class="+ topic/ph hi-d/i ph i">/* Status of the IRP */</em>
    USB_HOST_IRP_STATUS status;

    <em class="+ topic/ph hi-d/i ph i">/* Request specific flags */</em>
    USB_HOST_IRP_FLAG flags;

    <em class="+ topic/ph hi-d/i ph i">/* User data */</em>
    uintptr_t userData;

    <em class="+ topic/ph hi-d/i ph i">/* Pointer to function to be called when IRP is terminated. Can be NULL, in
     * which case the function will not be called. */</em>
    <strong class="+ topic/ph hi-d/b ph b">void</strong> (*callback)(<strong class="+ topic/ph hi-d/b ph b">struct</strong> _USB_HOST_IRP * irp);

    <em class="+ topic/ph hi-d/i ph i">/****************************************
     * These members of the IRP should not be
     * modified by client
     ****************************************/</em>
   uintptr_t privateData[7];

} USB_HOST_IRP;</pre>
        <p class="- topic/p p">The <code class="+ topic/ph pr-d/codeph ph codeph">setup</code> member of the USB_HOST_IRP structure must point to the 8 byte
            setup packet for control transfers. The driver will send this 8 byte data in the Setup
            phase of the control transfer. It can be NULL for non-control transfers. This member is
            only considered if the IRP is submitted to a control transfer pipe. It is ignored for
            non-control transfer pipes. The structure of the setup command should match that
            specified in the USB 2.0 specification. </p>
        <p class="- topic/p p">The <code class="+ topic/ph pr-d/codeph ph codeph">data</code> member of the USB_HOST_IRP structure points to a data buffer.
            This data buffer will contain the data that needs to be sent to the device for data
            stage of a OUT transfer, or it will contain the data that was received from the device
            during an IN transfer. Any hardware specific cache coherency and address alignment
            requirements must be considered while allocating this data buffer. The Driver Client
            should not modify or examine the contents of the IRP after the IRP has been submitted
            and is being processed. It can be examined after the driver has released the IRP. </p>
        <p class="- topic/p p">The <code class="+ topic/ph pr-d/codeph ph codeph">size</code> member of the USB_HOST_IRP structure contains the size of the
            transfer. for Bulk transfers, the size of the transfer can exceed the size of the
            transaction (which is equal to size of the endpoint reported by the device). The HCD in
            such a case will split up the transfer into transactions. This process does not require
            external intervention. For control transfers, the size of the transfer is specified in
            the setup packet (pointed to by the <code class="+ topic/ph pr-d/codeph ph codeph">setup</code> member of the USB_HOST_IRP
            structure). The driver will itself process the Setup, Data (if required) and Handshake
            stages of control transfer. This process again does not require external intervention.
            For interrupt and isochronous transfers, the size of transfer specified in the IRP
            cannot exceed the size of the transaction. If size is specified as 0, then the driver
            will send a zero length packet. The <code class="+ topic/ph pr-d/codeph ph codeph">size</code> parameter of the IRP is
            updated by the driver when IRP processing is completed. This will contain the size of
            the completed transfer. </p>
        <p class="- topic/p p">The <code class="+ topic/ph pr-d/codeph ph codeph">status</code> member of the IRP provides the completion status of the IRP
            and should be checked only when the IRP processing has completed. This is indicated by
            the driver calling the IRP callback function. The IRP status is a USB_HOST_IRP_STATUS
            type. The following code example shows the different possible values of the
                <code class="+ topic/ph pr-d/codeph ph codeph">status</code> member and an example of submit a control transfer IRP.</p>
        <pre class="- topic/pre pre" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_HZW_Y1F_Q1C" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_HZW_Y1F_Q1C"><em class="+ topic/ph hi-d/i ph i">/* The following code shows an example of how the Host Layer populates
 * the IRP object and then submits it. IRP_Callback function is called when an
 * IRP has completed processing. The status of the IRP at completion can be
 * checked in the status flag. The size field of the irp will contain the amount
 * of data transferred. */</em>
<strong class="+ topic/ph hi-d/b ph b">void</strong> IRP_Callback(USB_HOST_IRP * irp)
{
    <em class="+ topic/ph hi-d/i ph i">/* irp is pointing to the IRP for which the callback has occurred. In most
     * cases this function will execute in an interrupt context. The application
     * should not perform any hardware access or interrupt unsafe operations in
     * this function. */</em>
<strong class="+ topic/ph hi-d/b ph b">switch</strong>(irp-&gt;status)
    {
        <strong class="+ topic/ph hi-d/b ph b">case</strong> USB_HOST_IRP_STATUS_ERROR_UNKNOWN:
            <em class="+ topic/ph hi-d/i ph i">/* IRP was terminated due to an unknown error */</em>
            <strong class="+ topic/ph hi-d/b ph b">break</strong>;

        <strong class="+ topic/ph hi-d/b ph b">case</strong> USB_HOST_IRP_STATUS_ABORTED:
            <em class="+ topic/ph hi-d/i ph i">/* IRP was terminated by the application */</em>
            <strong class="+ topic/ph hi-d/b ph b">break</strong>;

        <strong class="+ topic/ph hi-d/b ph b">case</strong> USB_HOST_IRP_STATUS_ERROR_BUS:
            <em class="+ topic/ph hi-d/i ph i">/* IRP was terminated due to a bus error */</em>
            <strong class="+ topic/ph hi-d/b ph b">break</strong>;

        <strong class="+ topic/ph hi-d/b ph b">case</strong> USB_HOST_IRP_STATUS_ERROR_DATA:
            <em class="+ topic/ph hi-d/i ph i">/* IRP was terminated due to data error */</em>
            <strong class="+ topic/ph hi-d/b ph b">break</strong>;

        <strong class="+ topic/ph hi-d/b ph b">case</strong> USB_HOST_IRP_STATUS_ERROR_NAK_TIMEOUT:
            <em class="+ topic/ph hi-d/i ph i">/* IRP was terminated because of a NAK timeout */</em>
            <strong class="+ topic/ph hi-d/b ph b">break</strong>;

        <strong class="+ topic/ph hi-d/b ph b">case</strong> USB_HOST_IRP_STATUS_ERROR_STALL:
            <em class="+ topic/ph hi-d/i ph i">/* IRP was terminated because of a device sent a STALL */</em>
            <strong class="+ topic/ph hi-d/b ph b">break</strong>;

        <strong class="+ topic/ph hi-d/b ph b">case</strong> USB_HOST_IRP_STATUS_COMPLETED:
            <em class="+ topic/ph hi-d/i ph i">/* IRP has been completed */</em>
            <strong class="+ topic/ph hi-d/b ph b">break</strong>;

        <strong class="+ topic/ph hi-d/b ph b">case</strong> USB_HOST_IRP_STATUS_COMPLETED_SHORT:
            <em class="+ topic/ph hi-d/i ph i">/* IRP has been completed but the amount of data processed was less
             * than requested. */</em>
            <strong class="+ topic/ph hi-d/b ph b">break</strong>;

        <strong class="+ topic/ph hi-d/b ph b">default</strong>:
            <strong class="+ topic/ph hi-d/b ph b">break</strong>;
    }
}

<em class="+ topic/ph hi-d/i ph i">/* In the following code example the a control transfer IRP is submitted to a
 * control pipe. The setup parameter of the IRP points to the Setup command of
 * the control transfer. The direction of the data stage is specified by the
 * Setup packet. */</em>

USB_HOST_IRP irp;
USB_ERROR result;
USB_HOST_PIPE_HANDLE controlPipe;
USB_SETUP_PACKET setup;
uint8_t controlTransferData[32];

irp.setup = setup;
irp.data = controlTransferData;
irp.size = 32;
irp.flags = USB_HOST_IRP_FLAG_NONE ;
irp.userData = &amp;someApplicationObject;
irp.callback = IRP_Callback;

result = DRV_USBFS_HOST_IRPSubmit(controlPipeHandle, &amp;irp);

<strong class="+ topic/ph hi-d/b ph b">switch</strong>(result)
{
    <strong class="+ topic/ph hi-d/b ph b">case</strong> USB_ERROR_NONE:
        <em class="+ topic/ph hi-d/i ph i">/* The IRP was submitted successfully */</em>
        <strong class="+ topic/ph hi-d/b ph b">break</strong>;

    <strong class="+ topic/ph hi-d/b ph b">case</strong> USB_ERROR_HOST_PIPE_INVALID:
        <em class="+ topic/ph hi-d/i ph i">/* The specified pipe handle is not valid */</em><strong class="+ topic/ph hi-d/b ph b">break</strong>;

    <strong class="+ topic/ph hi-d/b ph b">case</strong> USB_ERROR_OSAL_FUNCTION:
        <em class="+ topic/ph hi-d/i ph i">/* An error occurred while trying to grab mutex */</em><strong class="+ topic/ph hi-d/b ph b">break</strong>;

    <strong class="+ topic/ph hi-d/b ph b">default</strong>:
        <strong class="+ topic/ph hi-d/b ph b">break</strong>;
}</pre>
        <p class="- topic/p p">The <code class="+ topic/ph pr-d/codeph ph codeph">flags</code> member of the USB_HOST_IRP structure specifies flags which
            affect the behavior of the IRP. The USB_HOST_IRP_FLAG enumeration specifies the
            available option. The USB_HOST_IRP_FLAG_SEND_ZLP causes the driver to add a Zero Length
            Packet (ZLP) to the data stage of the transfer when the transfer size is an exact
            multiple of the endpoint size. The USB_HOST_IRP_WAIT_FOR_ZLP flag will cause the driver
            to wait for a ZLP from the device in a case where the size of data received thus far in
            the transfer is an exact multiple of the endpoint size. </p>
        <p class="- topic/p p">The <code class="+ topic/ph pr-d/codeph ph codeph">callback</code> member of the USB_HOST_IRP structure points to a function
            which the driver calls when the IRP processing is completed. The Driver Client must
            implement this function and assign the pointer to this function to the
                <code class="+ topic/ph pr-d/codeph ph codeph">callback</code> member of the IRP. Every IRP can have its own callback
            function or one common callback function could be used. The callback function will
            execute in an interrupt context. The Driver Client should not execute interrupt unsafe,
            blocking, or computationally intensive operations in the callback function. The client
            can call hostIRPSubmit function in the IRP callback function to submit another IRP or
            resubmit the same IRP. The client can check the status and size of the IRP in the
            callback function. </p>
        <p class="- topic/p p">The <code class="+ topic/ph pr-d/codeph ph codeph">userData</code> member of the USB_HOST_IRP structure can be used by the
            client to associate a client specific context with the Host. This context can then be
            used by the client, in the IRP callback function to identify the context in which the
            IRP was submitted. This member is particularly useful if the client wants to implement
            one callback function for all IRPs. </p>
        <p class="- topic/p p">The <code class="+ topic/ph pr-d/codeph ph codeph">privateData</code> member of the IRP is used by the driver and should not
            be accessed or manipulated by the Driver Client. The following code examples show usage
            of IRPs to transfer data between the Host and the attached device and along with the
            different flags.</p>
        <pre class="- topic/pre pre" id="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_SRM_JGF_Q1C" data-ofbid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__PRE_SRM_JGF_Q1C"><em class="+ topic/ph hi-d/i ph i">/* The following code shows an example of submitting an IRP to send data
 * to a device. In this example we will request the driver to send a ZLP after
 * sending the last transaction. The driver will send the ZLP only if the size
 * of the transfer is a multiple of the endpoint size. This is not a control
 * transfer IRP. So the setup field of the IRP will be ignored.  */</em>

USB_HOST_IRP irp;
USB_ERROR result;
USB_HOST_PIPE_HANDLE bulkOUTPipeHandle;
uint8_t data[128];

irp.data = data;
irp.size = 128;
irp.flags = USB_HOST_IRP_FLAG_SEND_ZLP ;
irp.userData = &amp;someApplicationObject;
irp.callback = IRP_Callback;

result = DRV_USBFS_HOST_IPRSubmit( bulkOUTPipeHandle, &amp;irp );


<em class="+ topic/ph hi-d/i ph i">/* The following code shows an example of submitting an IRP to receive
 * data to a device. In this example we will request the driver to wait for a
 * ZLP after receiving the last transaction. The driver will wait for the ZLP
 * only if the size of the transfer is a multiple of the endpoint size. This is
 * not a control transfer IRP. So the setup field of the IRP will be ignored.
 * */</em>

USB_HOST_IRP irp;
USB_ERROR result;
USB_HOST_PIPE_HANDLE bulkINPipeHandle;
uint8_t data[128];

irp.data = data;
irp.size = 128;
irp.flags = USB_HOST_IRP_FLAG_WAIT_FOR_ZLP ;
irp.userData = &amp;someApplicationObject;
irp.callback = IRP_Callback;

result = DRV_USBFS_HOST_IPRSubmit( bulkINPipeHandle, &amp;irp );</pre>
    </div>
</article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">On this page</div><ul><li class="section-item"><div class="section-title"><a href="#GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_NDB_C1F_Q1C" data-tocid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_NDB_C1F_Q1C"><strong class="+ topic/ph hi-d/b ph b">Handling Host Mode Driver Events</strong></a></div></li><li class="section-item"><div class="section-title"><a href="#GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_BNC_D1F_Q1C" data-tocid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_BNC_D1F_Q1C"><strong class="+ topic/ph hi-d/b ph b">Root Hub Operation</strong></a></div></li><li class="section-item"><div class="section-title"><a href="#GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_MZT_K1F_Q1C" data-tocid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_MZT_K1F_Q1C"><strong class="+ topic/ph hi-d/b ph b">Root Hub Port Operation</strong></a></div></li><li class="section-item"><div class="section-title"><a href="#GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_B1J_41F_Q1C" data-tocid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_B1J_41F_Q1C"><strong class="+ topic/ph hi-d/b ph b">Opening and Closing a Pipe</strong></a></div></li><li class="section-item"><div class="section-title"><a href="#GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_NCZ_T1F_Q1C" data-tocid="GUID-364A16EE-4ABA-46E5-91D2-DD954EEEA6E1__SECTION_NCZ_T1F_Q1C"><strong class="+ topic/ph hi-d/b ph b">Transferring Data to an Attached Device</strong></a></div></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
    <div class="footer">
  <div class="mchp-wh-footer">
    <div class="mchp-footer">
      <div class="mchp-footer-tier1">
        <div class="spacer"></div>
        <div class="mchp-footer-container">
          <div class="mchp-footer-links mchp-social-media-links">
            <div class="mchp-component-items">
              <div class="mchp-component-item">
                <a class="cmp-image__link" href="https://www.facebook.com/pages/Microchip-Technology-Inc/20320981741" target="_blank">
                  <img class="cmp-image__image" alt="Microchip Facebook" src="oxygen-webhelp/template/resources/images/201016-corp-facebook.png"/>
                </a>
              </div>
              <div class="mchp-component-item">
                <a class="cmp-image__link" href="https://www.linkedin.com/company/microchip-technology" target="_blank">
                  <img class="cmp-image__image" alt="Microchip LinkedIn" src="oxygen-webhelp/template/resources/images/201016-corp-linkedin.png"/>
                </a>
              </div>
              <div class="mchp-component-item">
                <a class="cmp-image__link" href="https://twitter.com/MicrochipTech" target="_blank">
                  <img class="cmp-image__image" alt="Microchip Twitter" src="oxygen-webhelp/template/resources/images/201016-corp-twitter.png"/>
                </a>
              </div>
              <div class="mchp-component-item">
                <a class="cmp-image__link" href="https://www.youtube.com/user/MicrochipTechnology" target="_blank">
                  <img class="cmp-image__image" alt="Microchip YouTube" src="oxygen-webhelp/template/resources/images/201016-corp-youtube.png"/>
                </a>
              </div>
              <div class="mchp-component-item">
                <a class="cmp-image__link" href="https://www.instagram.com/microchiptechnologyinc/" target="_blank">
                  <img class="cmp-image__image" alt="Microchip Instagram" src="oxygen-webhelp/template/resources/images/201016-corp-instagram.png"/>
                </a>
              </div>
              <div class="mchp-component-item">
                <a class="cmp-image__link" href="https://www.weibo.com/microchiptech" target="_blank">
                  <img class="cmp-image__image" alt="Microchip Weibo" src="oxygen-webhelp/template/resources/images/201016-corp-weibo.png"/>
                </a>
              </div>
              <div class="mchp-component-item">
                <a class="cmp-image__link" href="https://www.microchip.com/en-us/about/blog" target="_blank">
                  <img class="cmp-image__image" alt="Microchip Blog" src="oxygen-webhelp/template/resources/images/201016-corp-blog.png"/>
                </a>
              </div>
            </div>
          </div>
          <div class="mchp-footer-links">
            <div class="mchp-component-items">
              <div class="mchp-component-item">
                <div class="link">
                  <a href="https://www.microchip.com/about-us/contact-us" class="mchp-link__link">Contact</a>
                  <span class="mchp-link__separator">|</span>
                </div>
              </div>
              <div class="mchp-component-item ">
                <div class="link">
                  <a href="https://www.microchip.com/en-us/about/legal-information" class="mchp-link__link">Legal</a>
                  <span class="mchp-link__separator">|</span>
                </div>
              </div>
              <div class="mchp-component-item ">
                <div class="link">
                  <a href="https://www.microchip.com/en-us/about/legal-information/privacy-policy" class="mchp-link__link">Privacy Policy</a>
                  <span class="mchp-link__separator">|</span>
                </div>
              </div>
              <div class="mchp-component-item ">
                <div class="link">
                  <a href="https://www.microchip.com/en-us/about/legal-information/microchip-cookie-statement" class="mchp-link__link">Cookies</a>
                  <span class="mchp-link__separator">|</span>
                </div>
              </div>
              <div class="mchp-component-item">
                <div class="link">
                  <a href="https://careers.microchip.com/" class="mchp-link__link">Careers</a>
                  <span class="mchp-link__separator"></span>
                </div>
              </div>
            </div>
          </div>
          <div class="mchp-footer-newsletter">
            <div class="cmp-text">
              <p>Stay on the leading edge with our blog</p>
            </div>
            <div class="mchp-button-wrapper">
              <a role="button" href="https://www.microchip.com/en-us/about/blog" class="mchp-button mchp-button-regular solid">
                <span class="mchp-button__span">MicroSolutions</span>
              </a>
            </div>
          </div>
        </div>
        <div class="graphic">
          <img src="oxygen-webhelp/template/resources/images/footer-graphic.png"/>
        </div>
      </div>
      <div class="mchp-footer-tier2">
        <p class="mchp-copyright">© Copyright 1998-2022 Microchip Technology Inc. All rights reserved.</p>
      </div>
    </div>
  </div>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async="true" src="https://www.googletagmanager.com/gtag/js?id=UA-2724382-19"></script>
  <script>
    window.dataLayer = window.dataLayer || [];  
    function gtag(){dataLayer.push(arguments);}  
    gtag('js', new Date());   
    gtag('config', 'UA-2724382-19');
  </script>
  
  <script type="text/javascript">_satellite.pageBottom();</script><!-- Adobe Analytics -->
  <script type="text/javascript" src="mchp-js/prepend.js"></script><!-- Package for viewing PDFs on mobile devices -->
  
</div>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
       
        </body>
</html>